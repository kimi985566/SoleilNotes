# 常见问题

## 在浏览器输入 URL 回车之后发生了什么

### 1. DNS解析

DNS解析的过程就是寻找哪台机器上有你需要资源的过程，寻找的过程遵循就近原则。

输入一个网址并按回车的时候浏览器会根据输入的URL去查找对应的IP，具体过程如下：

1. 首先是查找浏览器缓存，浏览器会保存一段时间内访问过的一些网址的DNS信息，不同浏览器保存的时常不等。
2. 如果没有找到对应的记录，这个时候浏览器会尝试调用操作系统缓存来继续查找这个网址的对应DNS信息。
3. 如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。
4. 如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是网络运营商，中国电信中国移动等），ISP也会有相应的ISP DNS服务器，就是本地DNS服务器，请求的域名基本上都能在这里找得到。
5. 如果还是没有的话， ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正的实体服务器则有几百台，分布于全球各大洲。
6. 如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不存在，它没有在网上正式注册过。或者域名过期了。

这也就是为什么有时候打开一个新页面会有点慢，因为如果本地没什么缓存，查找域名的过程要这样递归地查询下去，查找完还要一层层的向上返回。例如"mp3.baidu.com"，域名先是解析出这是个.com的域名，然后跑到管理.com域的服务器上进行进一步查询，然后是.baidu，最后是mp3， 所以域名结构为：三级域名.二级域名.一级域名。

> DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存 --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 根域名服务器。

### 2. 进行TCP连接：三次握手

浏览器终于得到了IP以后，向服务器发送TCP连接，TCP连接经过三次握手。

> - 客户机 TCP 首先向服务器 TCP 发送一个连接请求报文段（SYN = 1, seq = x）
> - 服务器 TCP 收到连接请求报文段，如同意，发送确认（SYN = 1，ACK = 1，seq = y，ack = x + 1）
> - 客户机收到确认报文段后，向服务器给出确认，（ACK = 1，ack = y + 1，seq = x + 1）

### 3. 浏览器发送HTTP请求

浏览器和服务器建立连接以后，浏览器接着给这个IP地址给服务器发送一个http请求，方式为get，例如访问www.baidu.com。其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。

这个get请求包含了主机（Host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的"代理人"，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。可能还会有Cookies，Cookies保存了用户的登陆信息，一般保存的是用户的JSESSIONID，在每次向服务器发送请求的时候会重复发送给服务器。

在建立连接发送请求时每个服务端需要和客户端保持通信，有很多客户端都会和服务器进行通信。服务器为了识别是哪个客户端与它通信，就必须用一个标识记录客户端的信息。客户端首次访问服务器，服务端返回响应时通过附带一个记录的客户端信息的标识来返回给客户端，这个标识就是JSESSIONID，JSESSIONID就放在了客户端的Cookies里。当客户端再次向服务器发送请求时上就使用上次记录的Cookies里面的JSESSIONID，这样服务器就知道是哪个浏览器了。这样他们之间就能保持通信了。

### 4. 服务器处理请求

服务器收到浏览器的请求以后），会解析这个请求（读请求头），然后生成一个响应头和具体响应内容。接着服务器会传回来一个响应头和一个响应，响应头告诉了浏览器一些必要的信息，例如重要的Status Code，2开头如200表示一切正常，3开头表示重定向，4开头是客户端错误，如404表示请求的资源不存在，5开头表示服务器端错误。响应就是具体的要请求的页面内容。

### 5. 浏览器解析渲染页面

1. 浏览器显示HTML
    - 当服务器返回响应之后，浏览器读取关于这个响应的说明书（响应头），然后开始解析这个响应并在页面上显示出来。
    - 浏览器打开一个网址的时候会慢慢加载这个页面，一部分一部分的显示，直到完全显示，知道最后的旋转进度条停止。因此在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了。

2. 浏览器向服务器发送请求获取嵌入在HTML中的对象
    - 在浏览器显示HTML时，打开一个网页的过程中，主页（index）页面框架传送过来以后，浏览器还会因页面上的静态资源多次发起连接请求，需要获取嵌入在HTML中的其他地址的资源。这时，浏览器会发送一些请求来获取这些文件。这些内容也要一点点地请求过来，所以标签栏转啊转，内容刷啊刷，最后全部请求并加载好了就终于好了。
    - 这时请求的内容是主页里面包含的一些资源，如图片，视频，css样式，JavaScript文件等等。
    - 这在文件属于静态文件，首次访问会留在浏览器的缓存中，过期才会从服务器去取。缓存的内容通常不会保存很久，因为难保网站不会被改动。
    - 静态的文件一般会从CDN中去取，CDN根据请求获取资源的时候可能还会用到负载均衡。

3. 浏览器发送异步（AJAX）请求
    - 对于那些动态的请求，动态网页等就必须要从服务器获取了。对于静态的页面内容，浏览器通常会进行缓存，而对于动态的内容，浏览器通常不会进行缓存。对于这些动态请求，Nginx可能会专门设置一些服务器用来处理这些访问动态页面的请求。

### 6. 关闭TCP连接

当数据完成请求到返回的过程之后，根据Connection的Keep-Alive属性可以选择是否断开TCP连接，HTTP/1.1一般支持同一个TCP多个请求，而不是1.0版本下的完成一次请求就发生断开。TCP的断开与连接不一样，断开可以分为主动关闭和被动关闭，需要经过4次握手。

> - 客户机向其 TCP 发送一个**连接释放报文段**，并停止发送数据，主动关闭 TCP 连接（终止位 FIN = 1，seq = u）
> - 服务器收到连接释放报文段后即发出确认，客户到服务器这个方向的连接解决释放了-半关闭（ACK = 1，seq = v，ack = u + 1）
> - 服务器通知客户端 **TCP释放连接**，主动关闭TCP连接（FIN = 1，ACK = 1，seq = w，ack = v + 1）
> - 客户机收到连接释放报文后，发出确认（ACK = 1，seq = u + 1，ack = w + 1）

当浏览器需要的全部数据都已经加载完毕，一个页面就显示完了。

## 非对称加密和对称加密的区别

1. 加密和解密过程不同

- 对称加密过程和解密过程使用的同一个密钥，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。在对称加密中使用的主要算法有：DES（Data Encryption Standard）、3DES（Triple DES）、AES（Advanced Encryption Standard）、Blowfish等。
- 非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。

1. 加密解密速度不同

![](../asset/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.webp)

- 对称加密解密的速度比较快，适合数据比较长时的使用。对称加密中加密方和解密方使用同一个密钥，加密解密的速度比较快，耗时短，适合数据比较长时的使用。
- 非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。非对称加密使用一对秘钥，一个用来加密，一个用来解密，这样加密和解密花费时间就会更长长。

3. 传输的安全性不同

- 对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。
- 非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。

## TCP

- 面向连接：虚连接，不是完整的物理连接
- 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的：不能使用广播或多播方式
- 可靠有序，不丢不重：TCP提供可靠交付的服务，无差错，不丢失，不重复，按序到达
- 提供全双工的通信：
  - 发送缓存 准备发送的数据和已发送但尚未收到确认的数据
  - 接收缓存 按序到达但尚未被接收应用读取的数据和不按序到达的数据
- 面向字节流：把应用程序交下来的数据看成仅仅是一连串的无结构的字节流

### TCP常见问题

1. 为什么要三次握手

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、自己接收正常，对方发送、对方接收正常；Server 确认了：对方发送正常，自己接收正常
- 第三次握手：Client 确认了：自己发送、自己接收正常，对方发送、对方接收正常；Server 确认了：自己发送、自己接收正常，对方发送、对方接收正常

2. 第2次握手传回了ACK，为什么还要传回SYN

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”

3. 不能二次握手吗，第三次握手的重要性？

Server端会因接收了早已失效的报文，从而一直等待客户端的请求，最终导致死锁，资源浪费。

当客户端发出的第一个连接请求报文段无丢失，而是在某个网络节点长时间滞留了，导致延误到连接释放后的某个时间才到服务器，这种连接请求报文段是无效的。
当TCP连接只需要两次握手时，服务器端接收到了无效的连接请求报文段，就会误认为是客户端发出的一个新的连接请求，于是像客户端发出了确认报文段，同意建立TCP请求。因为假设了只需要两次握手，那么此时TCP连接就已经建立了。但是对客户端来说，它并没有发出建立连接的请求，所以不会向服务器端发送数据。但对服务器端了来说，因为它误以为客户端发出了建立连接的请求，所以它会一直等待客户端发送数据，最终导致死锁状态。

为了解决这个问题，就需要采用第三次握手，当服务器端发出了确认请求报文段之后，客户端并不会向服务器端的确认报文段发出确认，服务器收不到客户端发来的确认信息，就知道客户端并没有发出建立连接的请求，就不会一直等待客户端发送数据。所以三次握手就能确认双发收发功能都正常，缺一不可。

> SYN洪泛攻击
>
> - 从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时
> - 这就使得服务器易于受到SYN洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配

4. 为什么TCP释放连接需要四次挥手？

TCP连接提供全双工通信，即客户端收发信息，服务器端也可以收发信息。

TCP释放连接的目的是达到双方都无法接收信息。假设此时采用两次挥手，即客户端像服务器端发送了释放连接请求，并且服务器端返回确认释放连接信息时，此时，TCP连接是处于半关闭状态，即客户端无法发送信息给服务器端，但仍然可以接收来自服务器端的信息（服务器端可以发信息给客户端），因此需要再进行二次握手，即服务器端向客户端发送释放连接的请求，并且客户端向服务器端发送确认释放连接的请求，才真正完成释放（双向）。

补充：客户端再关闭连接前需要等待2MSL（MSL是最长报文段寿命）时间。

5. 为什么需要等待2MSL时间？

- ① 客户端发送的最后一个连接释放请求报文可能丢失，当服务器端接收不到连接释放确认报文时，不会进入关闭状态，但会超时重发连接释放报文。等待2MSL时间就是为了保证客户端发送的最后一个连接确认报文能够到达服务器。假设客户端没有等待2MSL时间就直接关闭连接，当客户端最后一个确认报文丢失时，服务器超时重发释放连接请求，因为此时客户端连接已经关闭，因此接收不到服务器发送的信息，服务器一直接收不到客户端发送的确认信息，导致无法进入关闭状态。
    - 解决这个方法就是让客户端关闭连接前等待2MSL时间，客户端发送最后一个确认报文段后，启动2MSL计时器。若最后一个报文段丢失，服务器超时重发，客户端也能再次接收到服务器的信息，并且重新发送释放连接确认报文段。
- ② 客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。防止早已失效的连接请求报文 出现在本连接中。

## UDP

- 无连接，减少开销和发送数据之前的时延
- 不保证可靠交付（由应用层保证）
- 面向报文，适合一次性传输少量数据的网络应用
- UDP无拥塞控制，适合很多实时应用（视频会话等）
- UDP首部开销小，8B，TCP 20B

### UDP常见问题

1. 什么是面向报文的?

应用层给UDP多长的报文，UDP就照样发送，即一次发一个完整报文。（因此使用UDP协议时需要考虑报文大小，适合传输少量数据的网络应用，报文也不能太小，会降低网络层的效率，大小要适当）

## HTTP

http是一种超文本传输协议，作用在应用层上，它规定了应用进程间通信的准则。

- 无状态（不保存状态，即无法记录用户的操作）
- 传输可靠性高

HTTP协议定义了浏览器（万维网用户进程）怎样向万维网服务器请求万维网文档，以及服务器怎么样把文档传送给浏览器

![](../asset/http%E8%BF%9E%E6%8E%A5.webp)

### HTTP的连接方式

1. 非持久连接: 在HTTP/1.0中默认使用非持久连接，客户端和服务器每进行一次HTTP操作，就建立一次连接（三次握手），任务结束就中断连接。
2. 持久连接: HTTP 1.1起，默认使用持久连接 ,默认开启Connection： keep-alive。
    - 非流水线式: 客户在收到前一个响应后才能发送下一个请求。
    - 流水线式：客户在收到HTTP的响应报文之前就能接着发送新的请求报文

### HTTP是不保存状态的协议,如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。

Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

如果Cookie 被禁用怎么办，最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。

## HTTPS

HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

1. TCP 三次同步握手
2. 客户端验证服务器数字证书
3. DH 算法协商对称加密算法的密钥、hash 算法的密钥
4. SSL 安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

## HTTP 和 HTTPS 的区别？

1. 端口
    - HTTP的URL由“http://”起始且默认使用端口80，
    - HTTPS的URL由“https://”起始且默认使用端口443。
2. 安全性和资源消耗：HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
    - HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份
    - HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。