# 线程安全

## 保证线程安全原理

1. 原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
2. 可见性，一个线程对值做出更改，其他线程需要能看到这个值以及被改变
3. 有序性，程序的执行要和代码的顺序一致。

对于线程安全，一般的做法是进行同步操作，在某一个时间点，只让一个线程来进行操作

## 保证线程安全操作

### synchronized

保证方法内部或代码块内部资源互斥访问,同一时间,由同一Monitor监视代码,最终只能有一个线程在访问

#### synchronized 修饰方法和修饰代码块的区别

主要是锁不同。

- 修饰方法时，对于静态方法，是把 class 作为锁；对于非静态方法，是把 this 对象当做锁；
- 修饰代码块时，是把任何对象作为锁，如果锁对象为空，会抛出 NullPointerException，但是修饰方法不会；
- 在锁的作用区域上，修饰方法时是整个方法体；而修饰代码块时只有对应的代码块。后者更加灵活和细粒度。
- 可以把修饰方法看作是修饰代码块的一种特殊形式，一种快捷方式。

### volatile

保证加了 volatile 关键字的字段的操作具有同步性,以及对 long 和 double的操作原子性(long double 原子性这个简单说一下就行).因此 volatile 可以看做简单版本的 synchronized,但是volatile只能保证基本数据类型有效果,无法修改类似 User.name 或 ++ 原子性问题

### java.util.concurrent.atomic包

下面有 AtomicInteger AtomicBoolean 等类,作用和 volatile 基本一致,可以看做通用版本的 volatile

```java
    AtomicInteger atomicInteger = new AtomicInteger(0);
    ...
    atomicInteger.getAndIncrement();
```

### Lock / ReentrantReadWriteLock

加锁机制,但是比 synchronized 麻烦,不推荐直接使用,最好用更复杂的锁 ReadWriteLock

```java
Lock lock = new ReentrantLock();
...
lock.lock(); try {
x++;
} finally {
    lock.unlock();
}
```
